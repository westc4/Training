Claude Task: Build a Jamendo CC-BY / CC-BY-SA Dataset Crawler (Jupyter Notebook)

Goal

Create a Jupyter notebook that can discover, filter, and download as much Jamendo audio as possible while restricting licenses to:
	•	CC-BY
	•	CC-BY-SA

…and explicitly excluding anything with NC or ND.

The notebook should be able to:
	•	resume if interrupted
	•	deduplicate
	•	validate downloads
	•	output a manifest (CSV/Parquet/JSONL) with full metadata + attribution fields
	•	compute total hours by license / genre / etc.

⸻

Constraints / Assumptions
	•	User is running on RunPod / Linux inside Jupyter (but code should be portable).
	•	Use the Jamendo API v3.0 for discovery and license metadata.
	•	Download using the Jamendo-provided URLs (and/or their “track/file” endpoint if needed).
	•	Must respect Jamendo’s API rate limits (implement backoff + retries).
	•	Download should be efficient (parallelism) but safe (don’t get banned).

⸻

Deliverable

A single notebook, e.g.:

jamendo_cc_by_downloader.ipynb

with these sections:
	1.	Config
	2.	API client
	3.	Track discovery + pagination
	4.	License filtering
	5.	Manifest writing + resume
	6.	Download manager
	7.	Validation + dedupe
	8.	Stats (hours, counts, failures)
	9.	Attribution export

⸻

Required Inputs (via environment variables or notebook inputs)
	•	JAMENDO_CLIENT_ID (required)
	•	Optional:
	•	OUT_DIR (default: ./jamendo_cc_dataset)
	•	MAX_TRACKS or MAX_PAGES (default: no limit)
	•	DOWNLOAD_WORKERS (default: 16)
	•	API_PAGE_SIZE (use max allowed by API)
	•	ALLOWED_LICENSES = {"cc-by", "cc-by-sa"} (canonical)
	•	EXCLUDE_LICENSE_KEYWORDS = {"nc", "nd"}

Important: Notebook should never print secrets.

⸻

Jamendo API Requirements (Claude must verify exact fields)

Claude should confirm in Jamendo API docs:
	•	correct endpoints for:
	•	listing tracks with include=licenses support
	•	retrieving download URLs / file endpoints
	•	exact license string formats returned (e.g., "cc-by", "CC BY", URLs, etc.)
	•	pagination parameters (e.g., offset/page, limit)
	•	rate limit behavior

If any fields are ambiguous, implement defensive parsing:
	•	accept license either as a canonical slug OR detect from the license URL text.

⸻

Data Model: Manifest Schema (must be created)

Write as JSONL (append-only) plus periodic Parquet compaction.

Each record must include:

Identity / provenance
	•	source: "jamendo"
	•	jamendo_track_id
	•	jamendo_artist_id
	•	jamendo_album_id (if available)
	•	retrieved_at (UTC ISO)

License / attribution
	•	license_slug (canonical: cc-by or cc-by-sa)
	•	license_url
	•	artist_name
	•	track_name
	•	attribution_text (ready-to-use)
	•	track_page_url (Jamendo page)

Audio metadata
	•	duration_sec
	•	audio_format (mp3, ogg, etc., if known)
	•	audio_download_url (actual file URL used)
	•	filesize_bytes (if available or after download)

Local file tracking
	•	local_relpath
	•	sha256
	•	download_status (ok, skipped_exists, failed)
	•	error_message (if failed)

Optional enrichment (if available)
	•	tags / genres
	•	BPM / key (likely not available; only include if present)
	•	waveform sample rate (derive via ffprobe post-download)

⸻

Dedupe & Resume Rules
	•	Maintain a local SQLite DB or a seen_ids.jsonl / seen_ids.parquet:
	•	jamendo_track_id uniqueness
	•	sha256 uniqueness (post-download dedupe)
	•	If file exists and hash matches → skipped_exists
	•	If partial download exists → resume download if supported OR re-download safely.

⸻

Download Implementation Requirements
	•	Use httpx or aiohttp for async downloads OR aria2c as a subprocess.
	•	Implement:
	•	max concurrency
	•	retries with exponential backoff
	•	timeouts
	•	content-length checks
	•	write-to-temp then atomic rename

Preferred: aria2c for speed + robustness on RunPod:
	•	multi-connection per file
	•	parallel downloads
	•	resume support

But Claude should implement a fallback pure-Python downloader too.

⸻

Validation Requirements

After download:
	•	run ffprobe to validate:
	•	decodable audio
	•	duration close to expected (allow tolerance, e.g. ±2%)
	•	compute sha256
	•	optionally store sample_rate_hz, channels

⸻

Stats / Reporting

Notebook should print:
	•	total tracks discovered
	•	total passing license filter
	•	downloaded count
	•	failures count + top error reasons
	•	total duration hours downloaded
	•	hours by license (BY vs BY-SA)
	•	estimated disk usage

⸻

Suggested Notebook Cells (explicit)

Claude should structure notebook as:
	1.	pip install cell (minimal deps)
	2.	imports
	3.	config + env
	4.	API client helpers
	5.	discovery loop (paginate → write manifest entries)
	6.	downloader (batch from manifest where status != ok)
	7.	validator pass
	8.	compaction (jsonl → parquet)
	9.	summary stats

⸻

Acceptance Criteria
	•	You can start the notebook, set JAMENDO_CLIENT_ID, choose OUT_DIR, and run end-to-end.
	•	It produces a manifest and audio files.
	•	It can stop mid-way and resume without duplicating downloads.
	•	License filter is strict and auditable.

⸻

Notes Claude Must Keep In Mind
	•	Jamendo includes CC licenses but not CC0; only BY and BY-SA matter here (still filter to avoid NC/ND).
	•	Do not scrape HTML unless API doesn’t expose required fields.
	•	Must be robust to API downtime and intermittent 403/429.

⸻

