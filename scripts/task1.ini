Claude Task #1: Jamendo CC-BY / CC-BY-SA “How Many Hours Exist?” (Metadata-Only, Jupyter Notebook)

Objective

Create a Jupyter notebook that uses the Jamendo API to:
	1.	Enumerate the Jamendo catalog (tracks)
	2.	Filter strictly to:
	•	CC-BY
	•	CC-BY-SA
	•	and exclude any license containing NC or ND
	3.	Compute:
	•	total track count
	•	total duration (hours)
	•	breakdowns by license type (BY vs BY-SA)
	•	optional breakdowns by genre / tags (if fields exist)
	4.	Output:
	•	jamendo_cc_hours_summary.json
	•	jamendo_cc_hours_by_license.csv
	•	and optionally jamendo_cc_tracks_manifest.parquet (metadata only, no audio URLs required)

No downloading audio. Metadata-only.

⸻

Why this matters

This notebook answers: “Does Jamendo contain 20k hours? 50k? 100k+?” for your strict license whitelist before you spend time pulling files.

⸻

Required Inputs
	•	JAMENDO_CLIENT_ID (env var or notebook input)
	•	Optional:
	•	API_PAGE_SIZE (use maximum allowed)
	•	MAX_PAGES (for test mode; default = None / crawl all)
	•	CHECKPOINT_EVERY_PAGES (default 25)
	•	STATE_DIR (default ./jamendo_cc_audit_state)
	•	OUTPUT_DIR (default ./jamendo_cc_audit_output)

⸻

Notebook Structure (must be clean and modular)

1) Setup
	•	Install minimal deps:
	•	httpx (or requests)
	•	pandas
	•	pyarrow (optional but recommended)
	•	tqdm
	•	tenacity (retry/backoff) or custom backoff

2) Config
	•	Read env vars
	•	Define license allowlist:
	•	ALLOWED = {"cc-by", "cc-by-sa"}
	•	DISALLOWED_KEYWORDS = {"nc", "nd"}
	•	Define a robust function canonicalize_license(x):
	•	Accept slug strings or license URLs or human-readable forms.
	•	Return cc-by, cc-by-sa, or None.

Claude MUST verify what Jamendo returns for license fields using the API docs and by sampling a few records.

3) API Client
	•	Functions:
	•	jamendo_get(endpoint, params) -> dict
	•	Retry on 429/5xx with exponential backoff
	•	Respect rate limiting (sleep/jitter)
	•	Pagination handling:
	•	Works with Jamendo’s real pagination model (page/offset/limit).
	•	Must be able to run “crawl all” safely.

4) Crawl Loop

For each page:
	•	Fetch track list (with licenses included)
	•	Extract per track:
	•	track_id, track_name
	•	artist_id, artist_name
	•	album_id (if any)
	•	duration_sec
	•	license info (slug + url if available)
	•	track_page_url
	•	optionally tags, genres, audiodownload_allowed if present
	•	Apply license filter strictly.
	•	Append passing records to an append-only JSONL checkpoint file.

Checkpointing / resume is mandatory
	•	Keep a state.json with:
	•	last processed page/offset
	•	counts to date
	•	wall clock stats
	•	If notebook is restarted, it continues where it left off without reprocessing.

5) Aggregation

After crawl:
	•	Read JSONL into DataFrame (or stream-reduce to avoid RAM blowup)
	•	Compute:
	•	total tracks passing filter
	•	total duration seconds + hours
	•	hours by license (cc-by, cc-by-sa)
	•	optional: distribution of durations, percentiles
	•	Save outputs:
	•	summary JSON
	•	CSV breakdown table(s)
	•	optional Parquet metadata table for later downloader integration

⸻

Output Files (exact)

In OUTPUT_DIR/:
	1.	jamendo_cc_tracks_metadata.jsonl (append-only raw filtered metadata)
	2.	jamendo_cc_hours_summary.json (topline metrics)
	3.	jamendo_cc_hours_by_license.csv (license breakdown)
	4.	jamendo_cc_duration_stats.csv (p50/p90/p99 duration, etc.)
	5.	Optional: jamendo_cc_tracks_metadata.parquet (for fast joins later)

⸻

Validation & Audit Requirements
	•	The notebook must log:
	•	how many total tracks were scanned (overall)
	•	how many were filtered in/out and why
	•	License parsing must be auditable:
	•	store raw license field(s) and canonicalized value
	•	Include a cell that prints 10 sample passing tracks and 10 sample rejected tracks with their license fields.

⸻

Performance Constraints
	•	Must handle large catalogs without exhausting memory:
	•	stream to JSONL during crawl
	•	do aggregation either:
	•	by chunking JSONL read, or
	•	via incremental counters (recommended)
	•	Provide a “dry run” mode:
	•	MAX_PAGES=5 to confirm API + parsing

⸻

Acceptance Criteria
	•	I can run it with only JAMENDO_CLIENT_ID.
	•	It crawls, resumes, and outputs total hours for CC-BY/CC-BY-SA only.
	•	It produces a clear breakdown and a manifest usable by the downloader notebook later.

⸻

Optional enhancement (nice to have)

A “headroom estimator” cell:
	•	given average audio bitrate assumption (e.g., 192 kbps mp3),
	•	estimate disk size for full download by license group.

⸻