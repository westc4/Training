#!/usr/bin/env python3
"""
Sync RunPod Pods into ~/.ssh/config (managed block).

- Adds SSH host entries for pods that have:
  - publicIp
  - portMappings["22"] (direct TCP mapping)
- Removes entries for pods that no longer meet that criteria.

Auth:
  export RUNPOD_API_KEY="..."

Usage:
  python3 runpod_ssh_sync.py --key ~/.ssh/id_ed25519
  python3 runpod_ssh_sync.py --dry-run
"""

from __future__ import annotations

import argparse
import json
import os
import re
import sys
import urllib.request
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

RUNPOD_PODS_URL = "https://rest.runpod.io/v1/pods"

BEGIN = "# BEGIN RUNPOD MANAGED (do not edit)\n"
END = "# END RUNPOD MANAGED\n"

def http_get_json(url: str, token: str, timeout: int = 20) -> Any:
    req = urllib.request.Request(url)
    req.add_header("Authorization", f"Bearer {token}")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        data = resp.read().decode("utf-8")
    return json.loads(data)

def sanitize_host(s: str) -> str:
    s = s.strip().lower()
    s = re.sub(r"[^a-z0-9._-]+", "-", s)
    s = re.sub(r"-{2,}", "-", s).strip("-")
    return s or "pod"

def pick_host_alias(pod: Dict[str, Any]) -> str:
    pod_id = str(pod.get("id", ""))[:8] or "unknown"
    name = pod.get("name") or pod.get("image") or "runpod"
    return f"runpod-{sanitize_host(str(name))}-{pod_id}"

def extract_ssh_target(pod: Dict[str, Any]) -> Optional[Tuple[str, str, int]]:
    """
    Returns (host_alias, public_ip, external_port) if pod is SSH-reachable via direct TCP 22 mapping.
    """
    public_ip = pod.get("publicIp")
    port_mappings = pod.get("portMappings") or {}
    # docs show mapping like {"22": 10341}
    ext_port = port_mappings.get("22") or port_mappings.get(22)

    if not public_ip or not ext_port:
        return None

    try:
        ext_port_int = int(ext_port)
    except Exception:
        return None

    host_alias = pick_host_alias(pod)
    return host_alias, str(public_ip), ext_port_int

def render_ssh_block(
    entries: List[Tuple[str, str, int]],
    user: str,
    identity_file: str,
    extra: bool,
) -> str:
    lines: List[str] = []
    lines.append(BEGIN.rstrip("\n"))
    lines.append(f"# Generated by runpod_ssh_sync.py. Source: {RUNPOD_PODS_URL}")
    if not entries:
        lines.append("# (no SSH-reachable pods found)")
        lines.append(END.rstrip("\n"))
        return "\n".join(lines) + "\n"

    for alias, ip, port in sorted(entries, key=lambda x: x[0]):
        lines.append("")
        lines.append(f"Host {alias}")
        lines.append(f"  HostName {ip}")
        lines.append(f"  User {user}")
        lines.append(f"  Port {port}")
        lines.append(f"  IdentityFile {identity_file}")
        lines.append("  IdentitiesOnly yes")
        lines.append("  ServerAliveInterval 30")
        lines.append("  ServerAliveCountMax 3")
        # Optional conveniences (safer to keep known_hosts normal, but these reduce friction)
        if extra:
            lines.append("  StrictHostKeyChecking no")
            lines.append("  UserKnownHostsFile /dev/null")

    lines.append("")
    lines.append(END.rstrip("\n"))
    return "\n".join(lines) + "\n"

def upsert_managed_block(config_text: str, new_block: str) -> str:
    pattern = re.compile(
        r"(?ms)^# BEGIN RUNPOD MANAGED \(do not edit\)\n.*?^# END RUNPOD MANAGED\n"
    )
    if pattern.search(config_text):
        return pattern.sub(new_block, config_text, count=1)

    # If no managed block exists, append at end with a newline separator.
    if config_text and not config_text.endswith("\n"):
        config_text += "\n"
    return config_text + ("\n" if config_text else "") + new_block

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", default=str(Path.home() / ".ssh" / "config"))
    ap.add_argument("--user", default="root")
    ap.add_argument("--key", default=str(Path.home() / ".ssh" / "id_ed25519"))
    ap.add_argument("--dry-run", action="store_true")
    ap.add_argument("--timeout", type=int, default=20)
    ap.add_argument(
        "--insecure-known-hosts",
        action="store_true",
        help="Add StrictHostKeyChecking no + UserKnownHostsFile /dev/null inside managed entries.",
    )
    args = ap.parse_args()

    token = os.environ.get("RUNPOD_API_KEY") or os.environ.get("RUNPOD_TOKEN")
    if not token:
        print("ERROR: Set RUNPOD_API_KEY in your environment.", file=sys.stderr)
        return 2

    ssh_config_path = Path(args.config).expanduser()
    ssh_config_path.parent.mkdir(parents=True, exist_ok=True)

    # Fetch pods
    pods = http_get_json(RUNPOD_PODS_URL, token=token, timeout=args.timeout)
    if not isinstance(pods, list):
        print("ERROR: Unexpected API response (expected list).", file=sys.stderr)
        return 3

    entries: List[Tuple[str, str, int]] = []
    for pod in pods:
        if not isinstance(pod, dict):
            continue
        t = extract_ssh_target(pod)
        if t:
            entries.append(t)

    new_block = render_ssh_block(
        entries=entries,
        user=args.user,
        identity_file=str(Path(args.key).expanduser()),
        extra=args.insecure_known_hosts,
    )

    old_text = ""
    if ssh_config_path.exists():
        old_text = ssh_config_path.read_text(encoding="utf-8")

    updated = upsert_managed_block(old_text, new_block)

    if args.dry_run:
        print(updated)
        return 0

    ssh_config_path.write_text(updated, encoding="utf-8")
    try:
        os.chmod(ssh_config_path, 0o600)
    except Exception:
        pass

    print(f"Updated {ssh_config_path} with {len(entries)} RunPod SSH host(s).")
    if entries:
        print("Examples:")
        for alias, ip, port in entries[:5]:
            print(f"  ssh {alias}    # -> {ip}:{port}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())